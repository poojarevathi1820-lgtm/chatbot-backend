# Code Generated by Sidekick is for learning and experimentation purposes only.
import os
import json
import re
from typing import Optional

import uvicorn
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from supabase.client import Client, create_client

from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnableBranch, RunnableLambda
from langchain_core.output_parsers import StrOutputParser
from langchain_google_genai import ChatGoogleGenerativeAI

# --- STATIC DATA ---

FAQS = {
    "best material": "The best material depends on your needs. TPU and silicone offer flexibility and grip, polycarbonate is very durable, and leather is stylish.",
    "protect from drops": "Yes, our cases are designed to protect your phone from everyday bumps and drops. Rugged and shockproof models offer the highest protection.",
    "wireless charging": "Most of our slim and regular-fit cases are compatible with wireless charging. Very thick or metal cases may interfere.",
    "clean case": "Gently scrub with warm water and dish soap. For tough stains, use a baking soda paste. Remove your phone before cleaning.",
    "yellow case": "Yellowing is due to UV and skin oils. Cleaning with baking soda may help, but regular cleaning is best to prevent it.",
    "warranty": "We offer a one-year warranty covering manufacturing defects. Contact support with proof of purchase for claims."
}

FAQ_KEYWORDS = {
    "material": "best material",
    "drop": "protect from drops",
    "drops": "protect from drops",
    "wireless": "wireless charging",
    "charging": "wireless charging",
    "clean": "clean case",
    "yellow": "yellow case",
    "warranty": "warranty"
}

FAQ_PHRASES = [
    ("best material", ["best material", "what material", "which material"]),
    ("protect from drops", ["protect from drops", "drop protection", "protect my phone", "shockproof"]),
    ("wireless charging", ["wireless charging", "charge wirelessly", "wireless charger", "support wireless"]),
    ("clean case", ["clean case", "how to clean", "clean my case", "cleaning case"]),
    ("yellow case", ["yellow case", "case turned yellow", "clear case yellow", "yellowing"]),
    ("warranty", ["warranty", "guarantee", "return policy", "replace my case"])
]

# --- INTENT DETECTION ---

def detect_static_intent(message: str) -> Optional[str]:
    msg = message.lower().strip()
    tokens = set(re.findall(r'\w+', msg))

    # Top selling detection
    top_selling_patterns = [
        r"\btop selling\b",
        r"\bbest sellers\b",
        r"\bmost popular\b",
        r"\bpopular cases\b",
        r"\bbest selling\b",
        r"\bshow me top selling\b",
        r"\bsee top selling\b",
        r"\bany top selling\b",
        r"\bcan i see top selling\b",
        r"\bdo you have top selling\b",
        r"\bwhat are your top selling\b"
    ]
    for pattern in top_selling_patterns:
        if re.search(pattern, msg):
            return "top_selling"
    if (
        ("top" in tokens and ("selling" in tokens or "seller" in tokens or "sellers" in tokens)) or
        ("best" in tokens and ("seller" in tokens or "sellers" in tokens or "selling" in tokens)) or
        ("popular" in tokens and ("case" in tokens or "cases" in tokens))
    ):
        return "top_selling"

    # New arrivals detection
    new_arrivals_patterns = [
        r"\bnew arrivals\b",
        r"\bjust arrived\b",
        r"\bnew cases\b",
        r"\blatest arrivals\b",
        r"\blatest cases\b",
        r"\bshow me new arrivals\b",
        r"\bsee new arrivals\b",
        r"\bany new arrivals\b",
        r"\bcan i see new arrivals\b",
        r"\bdo you have new arrivals\b",
        r"\bwhat are your new arrivals\b"
    ]
    for pattern in new_arrivals_patterns:
        if re.search(pattern, msg):
            return "new_arrivals"
    if (
        ("new" in tokens and ("arrival" in tokens or "arrivals" in tokens or "case" in tokens or "cases" in tokens)) or
        ("latest" in tokens and ("arrival" in tokens or "arrivals" in tokens or "case" in tokens or "cases" in tokens)) or
        ("just" in tokens and "arrived" in tokens)
    ):
        return "new_arrivals"

    # FAQ detection
    for faq_key, phrases in FAQ_PHRASES:
        for phrase in phrases:
            if phrase in msg:
                return "faq"
    for keyword in FAQ_KEYWORDS:
        if keyword in tokens or keyword + "s" in tokens:
            return "faq"

    return None

def match_faq(user_message: str) -> Optional[str]:
    msg = user_message.lower()
    tokens = set(re.findall(r'\w+', msg))
    for faq_key, phrases in FAQ_PHRASES:
        for phrase in phrases:
            if phrase in msg:
                return f"<b>FAQ:</b> {FAQS[faq_key]}"
    for keyword, faq_key in FAQ_KEYWORDS.items():
        if keyword in tokens or keyword + "s" in tokens:
            return f"<b>FAQ:</b> {FAQS[faq_key]}"
    return None

def format_top_selling(results_json: str) -> str:
    try:
        results = json.loads(results_json)
        if "error" in results or not results:
            return "<p>Sorry, I couldn't find any top selling cases. Please try again later!</p>"
        results_to_display = results[:3]
        html_responses = ["<h3>Here are our top selling cases! ðŸ”¥</h3><div style='display:flex;flex-wrap:wrap;gap:16px;'>"]
        from urllib.parse import quote
        for case in results_to_display:
            case_id = case.get('id', '')
            name = case.get('name', 'N/A')
            cost = case.get('cost', 'N/A')
            image_url = case.get('image_url', '')
            encoded_image_url = quote(image_url, safe='')
            response_html = (
                f"<div style='width:150px;text-align:center;'>"
                f'<a href="product.html?id={case_id}&image_url={encoded_image_url}" target="_blank" title="View Details for {name}">'
                f"<img src='{image_url}' alt='{name}' style='width:100%;border-radius:8px;cursor:pointer;'/>"
                f"</a>"
                f"<div style='margin-top:8px;font-weight:bold;'>{name}</div>"
                f"<div style='margin-top:4px;'>â‚¹{cost}</div>"
                f"</div>"
            )
            html_responses.append(response_html)
        html_responses.append("</div><p>Let me know if you'd like more details or want to order any of these!</p>")
        return "".join(html_responses)
    except json.JSONDecodeError:
        return "<p>Error: I had trouble processing the top selling results.</p>"

def format_new_arrivals(results_json: str) -> str:
    try:
        results = json.loads(results_json)
        # Debugging: print the parsed results
        print("Formatted New Arrivals Results:", results)
        if "error" in results or not results:
            return "<p>Sorry, I couldn't find any new arrivals. Please check back soon!</p>"
        results_to_display = results[:3]
        html_responses = [
            "<h3>Check out our latest arrivals! ðŸ†•</h3><div style='display:flex;flex-wrap:wrap;gap:16px;'>"
        ]
        for case in results_to_display:
            case_id = case.get('id', '')
            name = case.get('name', 'N/A')
            cost = case.get('cost', 'N/A')
            image_url = case.get('image_url', '')
            response_html = (
                f"<div style='width:150px;text-align:center;'>"
                f'<a href="product.html?id={case_id}" target="_blank" title="View Details for {name}">'
                f"<img src='{image_url}' alt='{name}' style='width:100%;border-radius:8px;cursor:pointer;'/>"
                f"</a>"
                f"<div style='margin-top:8px;font-weight:bold;'>{name}</div>"
                f"<div style='margin-top:4px;'>â‚¹{cost}</div>"
                f"</div>"
            )
            html_responses.append(response_html)
        html_responses.append("</div>")
        if len(results) > 3:
            see_more_link = "<p style='text-align:center; margin-top: 20px;'><a href='cases.html?filter=new' target='_blank'>See More cases</a></p>"
            html_responses.append(see_more_link)
        return "".join(html_responses)
    except json.JSONDecodeError:
        return "<p>Error: I had trouble processing the new arrivals data.</p>"
    
def format_search_results(results_json: str) -> str:
    try:
        results = json.loads(results_json)
        if "error" in results or not results:
            return "<p>Sorry, I couldn't find any cases matching your search. Please try another model!</p>"
        results_to_display = results[:8]
        html_responses = [
            "<h3>Here are the top results I found:</h3><div style='display:flex;flex-wrap:wrap;gap:16px;'>"
        ]
        for case in results_to_display:
            case_id = case.get('id', '')
            name = case.get('name', 'N/A')
            cost = case.get('cost', 'N/A')
            image_url = case.get('image_url', '')
            response_html = (
                f"<div style='width:150px;text-align:center;'>"
                f'<a href="product.html?id={case_id}" target="_blank" title="View Details for {name}">'
                f"<img src='{image_url}' alt='{name}' style='width:100%;border-radius:8px;cursor:pointer;'/>"
                f"</a>"
                f"<div style='margin-top:8px;font-weight:bold;'>{name}</div>"
                f"<div style='margin-top:4px;'>â‚¹{cost}</div>"
                f"</div>"
            )
            html_responses.append(response_html)
        html_responses.append("</div>")
        if len(results) > 3:
            see_more_link = "<p style='text-align:center; margin-top: 20px;'><a href='cases.html' target='_blank'>See More Cases</a></p>"
            html_responses.append(see_more_link)
        return "".join(html_responses)
    except json.JSONDecodeError:
        return "<p>Error: I had trouble processing the search results.</p>"

def parse_brand_model(extracted: str) -> dict:
    brand = ''
    model = ''
    for part in extracted.split(','):
        part = part.strip()
        if part.lower().startswith('brand:'):
            brand = part.split(':', 1)[1].strip()
        elif part.lower().startswith('model:'):
            model = part.split(':', 1)[1].strip()
    return {'brand': brand, 'model': model}


def faq_how_to_order():
    return (
        "<b>How to order a phone case:</b><br>"
        "1. Search for your phone model or browse categories.<br>"
        "2. Select your preferred case and click 'Add to Cart' or 'Buy now'.<br>"
        "3. Review your cart and click 'Checkout'.<br>"
        "4. Enter shipping and payment details.<br>"
        "5. click place order"
        "If you need help, contact our support team!"
    )

# Code Generated by Sidekick is for learning and experimentation purposes only.
def search_cases_in_supabase(brand: str = "", model: str = "") -> str:
    try:
        query = supabase.table("cases").select(
            "id, name, model, brand, color, material, image_url, cost"
        )

        brand = brand.strip().lower()
        model = model.strip().lower()

        if brand and model:
            # Both brand and model provided: match both
            query = query.ilike("brand", f"%{brand}%").ilike("model", f"%{model}%")
        elif brand:
            # Only brand provided: search brand OR model
            query = query.or_(
                f"brand.ilike.%{brand}%,model.ilike.%{brand}%"
            )
        elif model:
            # Only model provided: search brand OR model
            query = query.or_(
                f"brand.ilike.%{model}%,model.ilike.%{model}%"
            )
        else:
            return json.dumps([])

        query = query.limit(10)
        response = query.execute()
        print(json.dumps(response.data, indent=2))
        return json.dumps(response.data) if response.data else json.dumps([])

    except Exception as e:
        print(f"!!! DATABASE ERROR: {e} !!!")
        return json.dumps({"error": "Failed to query the database."})

def search_new_arrivals_in_supabase() -> str:
    try:
        query = supabase.table("new_arrivals").select(
            "name,model,cost,id,image_url,arrived_date"
        ).order("arrived_date", desc=True).limit(10)
        response = query.execute()
        # Debugging: print the raw response
      #  print("New Arrivals Query Response:", response.data)
        return json.dumps(response.data) if response.data else json.dumps([])
    except Exception as e:
        print(f"!!! DATABASE ERROR: {e} !!!")
        return json.dumps({"error": "Failed to query the database."})
    
def search_top_selling_in_supabase() -> str:
    try:
        query = supabase.table("top_selling").select(
            "name,model,cost,image_url,id"
        ).limit(10)
        response = query.execute()
        return json.dumps(response.data) if response.data else json.dumps([])
    except Exception as e:
        print(f"!!! DATABASE ERROR: {e} !!!")
        return json.dumps({"error": "Failed to query the database."})
# Code Generated by Sidekick is for learning and experimentation purposes only.
def search_iphone_cases(brand: str = "iphone", model: str = "") -> str:
    try:
        query = supabase.table("cases").select(
            "id, name, model, brand, color, material, image_url, cost"
        )

        brand = brand.strip().lower()
        model = model.strip().lower()

        if brand and model:
            # Both brand and model provided: match both (AND)
            query = query.ilike("brand", f"%{brand}%").eq("model", model)
        elif model:
            # Only model provided: exact match on model
            query = query.eq("model", model)
        elif brand:
            # Only brand provided: match brand OR model
            query = query.or_(
                f"brand.ilike.%{brand}%,model.ilike.%{brand}%"
            )
        else:
            return json.dumps([])

        query = query.limit(10)
        response = query.execute()
        print(json.dumps(response.data, indent=2))
        return json.dumps(response.data) if response.data else json.dumps([])

    except Exception as e:
        print(f"!!! DATABASE ERROR: {e} !!!")
        return json.dumps({"error": "Failed to query the database."})

def format_iphone_cases(results_json: str) -> str:
    try:
        results = json.loads(results_json)

        if "error" in results or not results:
            return "<p>Sorry, I couldn't find any iPhone cases matching your search. Please try another model!</p>"

        results_to_display = results[:10]

        html_responses = [
            "<h3>Here are the top iPhone cases I found:</h3><div style='display:flex;flex-wrap:wrap;gap:16px;'>"
        ]

        for case in results_to_display:
            case_id = case.get('id', '')
            name = case.get('name', 'N/A')
            model = case.get('model', 'N/A')
            cost = case.get('cost', 'N/A')
            image_url = case.get('image_url', '')

            response_html = (
                f"<div style='width:150px;text-align:center;'>"
                f'<a href="product.html?id={case_id}" target="_blank" title="View Details for {name}">'
                f"<img src='{image_url}' alt='{name}' style='width:100%;border-radius:8px;cursor:pointer;'/>"
                f"</a>"
                f"<div style='margin-top:8px;font-weight:bold;'>{name}</div>"
                f"<div style='margin-top:4px;'>Model: {model}</div>"
                f"<div style='margin-top:4px;'>â‚¹{cost}</div>"
                f"</div>"
            )

            html_responses.append(response_html)

        html_responses.append("</div>")

        if len(results) > 3:
            see_more_link = "<p style='text-align:center; margin-top: 20px;'><a href='cases.html?brand=iphone' target='_blank'>See More iPhone Cases</a></p>"
            html_responses.append(see_more_link)

        return "".join(html_responses)

    except json.JSONDecodeError:
        return "<p>Error: I had trouble processing the iPhone case results.</p>"

# --- INITIALIZATION AND CONFIGURATION ---
# Code Generated by Sidekick is for learning and experimentation purposes only.
def fetch_order_history(user_id):
    response = supabase.table("orders").select("user_id,items,total_cost,status").eq("user_id", user_id).execute()
    return response.data if hasattr(response, 'data') else response
# Code Generated by Sidekick is for learning and experimentation purposes only.
def format_order_history(orders):
    if not orders:
        return "<p>No order history found for your account.</p>"

    html = "<b>Your order History:</b><br>"
    for idx, order in enumerate(orders, 1):
        html += f"<p><b>order {idx}:</b><br>"
        items = order.get('items', [])
        # If items is a JSON string, parse it
        if isinstance(items, str):
            import json
            try:
                items = json.loads(items)
            except Exception:
                items = []
        if not items:
            html += "â€¢ No items found for this order.<br>"
        else:
            for item in items:
                html += (
                    f"  <b>name:</b> {item.get('name', 'N/A')}<br>"
                    f"  <b>Brand:</b> {item.get('brand', 'N/A')}<br>"
                    f"  <b>Cost:</b> ${item.get('cost', 'N/A')}<br>"
                )
        html += f"<b>Status:</b> {order.get('status', 'N/A')}<br>"
        html += "</p>"
    return html



load_dotenv()
supabase_url = os.getenv("SUPABASE_URL")
supabase_key = os.getenv("SUPABASE_KEY")
google_api_key = os.getenv("GOOGLE_API_KEY")

if not all([supabase_url, supabase_key, google_api_key]):
    raise ValueError("Supabase URL/Key and Google API Key must be set in the .env file.")

try:
    supabase: Client = create_client(supabase_url, supabase_key)
    print("Successfully connected to Supabase.")
except Exception as e:
    print(f"Error connecting to Supabase: {e}")
    exit()

# --- API DATA SCHEMAS ---

class ChatRequest(BaseModel):
    message: str
    user_id: str = None

class ChatResponse(BaseModel):
    reply: str

# --- LANGCHAIN PIPELINE ---

llm = ChatGoogleGenerativeAI(model="gemini-1.5-flash-latest", temperature=0.0)

keyword_extraction_chain = (
    ChatPromptTemplate.from_template(
        "Extract the product brand and model from this message: {message}. "
        "Return as: brand: <brand>, model: <model>. If either is missing, leave blank."
    )
    | llm
    | StrOutputParser()
)

rag_chain = (
    {"message": lambda x: x["message"]}
    | {"extracted": keyword_extraction_chain}
    | RunnableLambda(lambda x: parse_brand_model(x["extracted"]))
    | RunnableLambda(lambda x: search_cases_in_supabase(brand=x["brand"], model=x["model"]))
    | RunnableLambda(format_search_results)
)

general_chat_chain = (
    ChatPromptTemplate.from_template("Respond warmly: {message}") | llm | StrOutputParser()
)

main_pipeline = (
    {"message": lambda x: x["message"]}
    | {
        "intent": ChatPromptTemplate.from_template(
            "Classify intent as 'product_search' or 'general_chat'. Message: {message}"
        ) | llm | StrOutputParser(),
        "message": lambda x: x["message"],
    }
    | RunnableBranch(
        (lambda x: "product_search" in x["intent"], rag_chain),
        general_chat_chain,
    )
)

# --- FASTAPI WEB SERVER ---

app = FastAPI(title="Supabase E-commerce Chatbot API")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/", summary="API Status Check")
def read_root():
    return {"status": "API is running"}

@app.get("/product/{product_id}", summary="Get Single Product Details")
async def get_product(product_id: str):
    try:
        response = supabase.table("cases").select("*").eq("id", product_id).single().execute()
        if not response.data:
            raise HTTPException(status_code=404, detail="Product not found")
        return response.data
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/chat", response_model=ChatResponse, summary="Handle Chat Messages")
async def chat(request: ChatRequest):
    print(f"Received message: '{request.message}'")
    print(f"Received user_id from frontend: {request.user_id}")  # <-- This prints user_id

    try:
        user_message = request.message.lower()

        # 1. Order history detection using regex for more flexibility
        order_history_patterns = [
            r"\border history\b",
            r"\bmy orders?\b",
            r"\bshow my orders?\b",
            r"\bshow my order\b",
            r"\bmy order history\b",
            r"\bview my orders?\b",
            r"\bsee my orders?\b",
            r"\btrack my orders?\b",
            r"\btrack my order\b",
        ]
        if any(re.search(pattern, user_message) for pattern in order_history_patterns):
            print("Bot intent: Fetch order history")
            user_id = request.user_id

            if not user_id or user_id == "anonymous":
                return ChatResponse(reply="<p>User not found. Please log in to view your order history.</p>")

            # --- Your order history logic here ---
            orders = fetch_order_history(user_id)
            return ChatResponse(reply=format_order_history(orders))

        # 2. FAQ: How to order
        if any(phrase in user_message for phrase in [
            "how to order", "order a case", "order phone case", "buy a case", "purchase a case", "how do i order"
        ]):
            print("Bot intent: FAQ (how to order)")
            return ChatResponse(reply=faq_how_to_order())

        # 3. Static intent detection
        static_intent = detect_static_intent(request.message)
        if static_intent == "top_selling":
            print("Bot intent: DB search (top_selling)")
            print("searching ...")
            results_json = search_top_selling_in_supabase()
            return ChatResponse(reply=format_top_selling(results_json))
        if static_intent == "new_arrivals":
            print("Bot intent: DB search (new_arrivals)")
            print("searching ...")
            results_json = search_new_arrivals_in_supabase()
            return ChatResponse(reply=format_new_arrivals(results_json))
        if static_intent == "faq":
            print("Bot intent: General answer (FAQ)")
            faq_answer = match_faq(request.message)
            if faq_answer:
                return ChatResponse(reply=faq_answer)
            # If intent is FAQ but no match, fallback to LLM

        # 4. iPhone case search
        if "iphone" in user_message:
            print("Bot intent: DB search (iphone)")
            print("searching ...")
            results_json = search_iphone_cases()
            return ChatResponse(reply=format_iphone_cases(results_json))

        # 5. Fallback: LLM pipeline
        pipeline_response = main_pipeline.invoke({"message": request.message})

        # Optional: classify and log intent for analytics
        intent_classifier = (
            ChatPromptTemplate.from_template(
                "Classify intent as 'product_search' or 'general_chat'. Message: {message}"
            ) | llm | StrOutputParser()
        )
        intent = intent_classifier.invoke({"message": request.message})

        if "product_search" in intent:
            print("Bot intent: DB search (product_search)")
            print("searching ...")
        else:
            print("Bot intent: General answer (chat)")

        return ChatResponse(reply=pipeline_response)

    except Exception as e:
        print(f"Error during pipeline invocation: {e}")
        raise HTTPException(status_code=500, detail=str(e))


if __name__ == "__main__":
    uvicorn.run("check:app", host="0.0.0.0", port=8000, reload=True)




"""@app.post("/chat", response_model=ChatResponse, summary="Handle Chat Messages")
async def chat(request: ChatRequest):
    print(f"Received message: '{request.message}'")
    try:
        user_message = request.message.lower()

        # 1. Order history detection using regex for more flexibility
        order_history_patterns = [
            r"\border history\b",
            r"\bmy orders?\b",
            r"\bshow my orders?\b",
            r"\bshow my order\b",
            r"\bmy order history\b",
            r"\bview my orders?\b",
            r"\bsee my orders?\b",
            r"\btrack my orders?\b",
            r"\btrack my order\b",
        ]
        if any(re.search(pattern, user_message) for pattern in order_history_patterns):
            print("Bot intent: Fetch order history")
            user_id = getattr(request, "user_id", None)
            if not user_id:
                return ChatResponse(reply="<p>User not found. Please log in to view your order history.</p>")
            orders = fetch_order_history(user_id)
            return ChatResponse(reply=format_order_history(orders))

        # 2. FAQ: How to order
        if any(phrase in user_message for phrase in [
            "how to order", "order a case", "order phone case", "buy a case", "purchase a case", "how do i order"
        ]):
            print("Bot intent: FAQ (how to order)")
            return ChatResponse(reply=faq_how_to_order())

        # 3. Static intent detection
        static_intent = detect_static_intent(request.message)
        if static_intent == "top_selling":
            print("Bot intent: DB search (top_selling)")
            print("searching ...")
            results_json = search_top_selling_in_supabase()
            return ChatResponse(reply=format_top_selling(results_json))
        if static_intent == "new_arrivals":
            print("Bot intent: DB search (new_arrivals)")
            print("searching ...")
            results_json = search_new_arrivals_in_supabase()
            return ChatResponse(reply=format_new_arrivals(results_json))
        if static_intent == "faq":
            print("Bot intent: General answer (FAQ)")
            faq_answer = match_faq(request.message)
            if faq_answer:
                return ChatResponse(reply=faq_answer)
            # If intent is FAQ but no match, fallback to LLM

        # 4. iPhone case search
        if "iphone" in user_message:
            print("Bot intent: DB search (iphone)")
            print("searching ...")
            results_json = search_iphone_cases()
            return ChatResponse(reply=format_iphone_cases(results_json))

        # 5. Fallback: LLM pipeline
        pipeline_response = main_pipeline.invoke({"message": request.message})

        # Optional: classify and log intent for analytics
        intent_classifier = (
            ChatPromptTemplate.from_template(
                "Classify intent as 'product_search' or 'general_chat'. Message: {message}"
            ) | llm | StrOutputParser()
        )
        intent = intent_classifier.invoke({"message": request.message})

        if "product_search" in intent:
            print("Bot intent: DB search (product_search)")
            print("searching ...")
        else:
            print("Bot intent: General answer (chat)")

        return ChatResponse(reply=pipeline_response)

    except Exception as e:
        print(f"Error during pipeline invocation: {e}")
        raise HTTPException(status_code=500, detail=str(e))
if __name__ == "__main__":
    uvicorn.run("check:app", host="0.0.0.0", port=8000, reload=True)"""