# Code Generated by Sidekick is for learning and experimentation purposes only.
import os
import json
import re
from typing import Optional

import uvicorn
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from supabase.client import Client, create_client

from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnableBranch, RunnableLambda
from langchain_core.output_parsers import StrOutputParser
from langchain_google_genai import ChatGoogleGenerativeAI

# --- STATIC DATA ---

FAQS = {
    "best material": "The best material depends on your needs. TPU and silicone offer flexibility and grip, polycarbonate is very durable, and leather is stylish.",
    "protect from drops": "Yes, our cases are designed to protect your phone from everyday bumps and drops. Rugged and shockproof models offer the highest protection.",
    "wireless charging": "Most of our slim and regular-fit cases are compatible with wireless charging. Very thick or metal cases may interfere.",
    "clean case": "Gently scrub with warm water and dish soap. For tough stains, use a baking soda paste. Remove your phone before cleaning.",
    "yellow case": "Yellowing is due to UV and skin oils. Cleaning with baking soda may help, but regular cleaning is best to prevent it.",
    "warranty": "We offer a one-year warranty covering manufacturing defects. Contact support with proof of purchase for claims."
}

FAQ_KEYWORDS = {
    "material": "best material",
    "drop": "protect from drops",
    "drops": "protect from drops",
    "wireless": "wireless charging",
    "charging": "wireless charging",
    "clean": "clean case",
    "yellow": "yellow case",
    "warranty": "warranty"
}

FAQ_PHRASES = [
    ("best material", ["best material", "what material", "which material"]),
    ("protect from drops", ["protect from drops", "drop protection", "protect my phone", "shockproof"]),
    ("wireless charging", ["wireless charging", "charge wirelessly", "wireless charger", "support wireless"]),
    ("clean case", ["clean case", "how to clean", "clean my case", "cleaning case"]),
    ("yellow case", ["yellow case", "case turned yellow", "clear case yellow", "yellowing"]),
    ("warranty", ["warranty", "guarantee", "return policy", "replace my case"])
]

# --- INTENT DETECTION ---

def detect_static_intent(message: str) -> Optional[str]:
    msg = message.lower().strip()
    tokens = set(re.findall(r'\w+', msg))

    # Top selling detection
    top_selling_patterns = [
        r"\btop selling\b",
        r"\bbest sellers\b",
        r"\bmost popular\b",
        r"\bpopular cases\b",
        r"\bbest selling\b",
        r"\bshow me top selling\b",
        r"\bsee top selling\b",
        r"\bany top selling\b",
        r"\bcan i see top selling\b",
        r"\bdo you have top selling\b",
        r"\bwhat are your top selling\b"
    ]
    for pattern in top_selling_patterns:
        if re.search(pattern, msg):
            return "top_selling"

    # Flexible token logic for top selling
    if (
        ("top" in tokens and ("selling" in tokens or "seller" in tokens or "sellers" in tokens)) or
        ("best" in tokens and ("seller" in tokens or "sellers" in tokens or "selling" in tokens)) or
        ("popular" in tokens and ("case" in tokens or "cases" in tokens))
    ):
        return "top_selling"

    # FAQ detection
    for faq_key, phrases in FAQ_PHRASES:
        for phrase in phrases:
            if phrase in msg:
                return "faq"
    for keyword in FAQ_KEYWORDS:
        if keyword in tokens or keyword + "s" in tokens:
            return "faq"

    return None

def match_faq(user_message: str) -> Optional[str]:
    msg = user_message.lower()
    tokens = set(re.findall(r'\w+', msg))
    for faq_key, phrases in FAQ_PHRASES:
        for phrase in phrases:
            if phrase in msg:
                return f"<b>FAQ:</b> {FAQS[faq_key]}"
    for keyword, faq_key in FAQ_KEYWORDS.items():
        if keyword in tokens or keyword + "s" in tokens:
            return f"<b>FAQ:</b> {FAQS[faq_key]}"
    return None

"""def format_top_selling(results_json: str) -> str:
    try:
        results = json.loads(results_json)
        if "error" in results or not results:
            return "<p>Sorry, I couldn't find any top selling cases. Please try again later!</p>"
        results_to_display = results[:3]
        html_responses = ["<h3>Here are our top selling cases! ðŸ”¥</h3><div style='display:flex;flex-wrap:wrap;gap:16px;'>"]
        for case in results_to_display:
            name = case.get('name', 'N/A')
            cost = case.get('cost', 'N/A')
            image_url = case.get('image_url', '')
            response_html = (
                f"<div style='width:150px;text-align:center;'>"
                f"<img src='{image_url}' alt='{name}' style='width:100%;border-radius:8px;'/>"
                f"<div style='margin-top:8px;font-weight:bold;'>{name}</div>"
                f"<div style='margin-top:4px;'>â‚¹{cost}</div>"
                f"</div>"
            )
            html_responses.append(response_html)
        html_responses.append("</div><p>Let me know if you'd like more details or want to order any of these!</p>")
        return "".join(html_responses)
    except json.JSONDecodeError:
        return "<p>Error: I had trouble processing the top selling results.</p>"""

# Code Generated by Sidekick is for learning and experimentation purposes only.
def format_top_selling(results_json: str) -> str:
    try:
        results = json.loads(results_json)
        if "error" in results or not results:
            return "<p>Sorry, I couldn't find any top selling cases. Please try again later!</p>"
        results_to_display = results[:3]
        html_responses = ["<h3>Here are our top selling cases! ðŸ”¥</h3><div style='display:flex;flex-wrap:wrap;gap:16px;'>"]
        from urllib.parse import quote
        for case in results_to_display:
            print(case)  # Debug: See if 'id' is present
            case_id = case.get('id', '')
            name = case.get('name', 'N/A')
            cost = case.get('cost', 'N/A')
            image_url = case.get('image_url', '')
            encoded_image_url = quote(image_url, safe='')
            response_html = (
                f"<div style='width:150px;text-align:center;'>"
                f'<a href="product.html?id={case_id}&image_url={encoded_image_url}" target="_blank" title="View Details for {name}">'
                f"<img src='{image_url}' alt='{name}' style='width:100%;border-radius:8px;cursor:pointer;'/>"
                f"</a>"
                f"<div style='margin-top:8px;font-weight:bold;'>{name}</div>"
                f"<div style='margin-top:4px;'>â‚¹{cost}</div>"
                f"</div>"
            )
            html_responses.append(response_html)
        html_responses.append("</div><p>Let me know if you'd like more details or want to order any of these!</p>")
        return "".join(html_responses)
    except json.JSONDecodeError:
        return "<p>Error: I had trouble processing the top selling results.</p>"


def parse_brand_model(extracted: str) -> dict:
    brand = ''
    model = ''
    for part in extracted.split(','):
        part = part.strip()
        if part.lower().startswith('brand:'):
            brand = part.split(':', 1)[1].strip()
        elif part.lower().startswith('model:'):
            model = part.split(':', 1)[1].strip()
    return {'brand': brand, 'model': model}

def search_cases_in_supabase(brand: str, model: str) -> str:
    try:
        query = supabase.table("cases").select(
            "id, name, model, brand, color, material, image_url, cost"
        )
        if brand and model:
            query = query.ilike("brand", f"%{brand}%").ilike("model", f"%{model}%")
        elif brand:
            query = query.ilike("brand", f"%{brand}%")
        elif model:
            query = query.ilike("model", f"%{model}%")
        else:
            return json.dumps([])
        query = query.limit(10)
        response = query.execute()
        return json.dumps(response.data) if response.data else json.dumps([])
    except Exception as e:
        print(f"!!! DATABASE ERROR: {e} !!!")
        return json.dumps({"error": "Failed to query the database."})

"""def format_search_results(results_json: str) -> str:
    try:
        results = json.loads(results_json)
        if "error" in results or not results:
            return "<p>Sorry, I couldn't find any cases matching your search. Please try another model!</p>"
        results_to_display = results[:3]
        html_responses = ["<p>Here are the top results I found:</p>"]
        for case in results_to_display:
            case_id = case.get('id', '')
            name = case.get('name', 'N/A')
            cost = case.get('cost', 'N/A')
            image_url = case.get('image_url', '')
            response_html = (
                f"<div style='margin-top: 15px;'>"
                f"<p style='margin:0; font-weight: bold;'>{name}</p>"
                f"<p style='margin:0;'><b>Price:</b> &#8377; {cost}</p>"
                f'<a href="product.html?id={case_id}" target="_blank" title="View Details for {name}">'
                f'<img src="{image_url}" alt="{name}" style="max-width: 100%; height: auto; border-radius: 10px; margin-top: 5px; cursor: pointer;" />'
                f'</a>'
                f"</div>"
            )
            html_responses.append(response_html)
        if len(results) > 3:
            see_more_link = "<p style='text-align:center; margin-top: 20px;'><a href='cases.html' target='_blank'>See More Cases</a></p>"
            html_responses.append(see_more_link)
        return "".join(html_responses)
    except json.JSONDecodeError:
        return "<p>Error: I had trouble processing the search results.</p>"""
# Code Generated by Sidekick is for learning and experimentation purposes only.
def format_search_results(results_json: str) -> str:
    try:
        results = json.loads(results_json)
        if "error" in results or not results:
            return "<p>Sorry, I couldn't find any cases matching your search. Please try another model!</p>"
        results_to_display = results[:3]
        html_responses = [
            "<h3>Here are the top results I found:</h3><div style='display:flex;flex-wrap:wrap;gap:16px;'>"
        ]
        for case in results_to_display:
            case_id = case.get('id', '')
            name = case.get('name', 'N/A')
            cost = case.get('cost', 'N/A')
            image_url = case.get('image_url', '')
            response_html = (
                f"<div style='width:150px;text-align:center;'>"
                f'<a href="product.html?id={case_id}" target="_blank" title="View Details for {name}">'
                f"<img src='{image_url}' alt='{name}' style='width:100%;border-radius:8px;cursor:pointer;'/>"
                f"</a>"
                f"<div style='margin-top:8px;font-weight:bold;'>{name}</div>"
                f"<div style='margin-top:4px;'>â‚¹{cost}</div>"
                f"</div>"
            )
            html_responses.append(response_html)
        html_responses.append("</div>")
        if len(results) > 3:
            see_more_link = "<p style='text-align:center; margin-top: 20px;'><a href='cases.html' target='_blank'>See More Cases</a></p>"
            html_responses.append(see_more_link)
        return "".join(html_responses)
    except json.JSONDecodeError:
        return "<p>Error: I had trouble processing the search results.</p>"


def search_top_selling_in_supabase() -> str:
    try:
        query = supabase.table("top_selling").select(
            "name,model,cost,image_url,id"
        ).limit(10)
        response = query.execute()
        return json.dumps(response.data) if response.data else json.dumps([])
    except Exception as e:
        print(f"!!! DATABASE ERROR: {e} !!!")
        return json.dumps({"error": "Failed to query the database."})

# --- INITIALIZATION AND CONFIGURATION ---

load_dotenv()
supabase_url = os.getenv("SUPABASE_URL")
supabase_key = os.getenv("SUPABASE_KEY")
google_api_key = os.getenv("GOOGLE_API_KEY")

if not all([supabase_url, supabase_key, google_api_key]):
    raise ValueError("Supabase URL/Key and Google API Key must be set in the .env file.")

try:
    supabase: Client = create_client(supabase_url, supabase_key)
    print("Successfully connected to Supabase.")
except Exception as e:
    print(f"Error connecting to Supabase: {e}")
    exit()

# --- API DATA SCHEMAS ---

class ChatRequest(BaseModel):
    session_id: str
    message: str

class ChatResponse(BaseModel):
    reply: str

# --- LANGCHAIN PIPELINE ---

llm = ChatGoogleGenerativeAI(model="gemini-1.5-flash-latest", temperature=0.0)

keyword_extraction_chain = (
    ChatPromptTemplate.from_template(
        "Extract the product brand and model from this message: {message}. "
        "Return as: brand: <brand>, model: <model>. If either is missing, leave blank."
    )
    | llm
    | StrOutputParser()
)

rag_chain = (
    {"message": lambda x: x["message"]}
    | {"extracted": keyword_extraction_chain}
    | RunnableLambda(lambda x: parse_brand_model(x["extracted"]))
    | RunnableLambda(lambda x: search_cases_in_supabase(brand=x["brand"], model=x["model"]))
    | RunnableLambda(format_search_results)
)

general_chat_chain = (
    ChatPromptTemplate.from_template("Respond warmly: {message}") | llm | StrOutputParser()
)

main_pipeline = (
    {"message": lambda x: x["message"]}
    | {
        "intent": ChatPromptTemplate.from_template(
            "Classify intent as 'product_search' or 'general_chat'. Message: {message}"
        ) | llm | StrOutputParser(),
        "message": lambda x: x["message"],
    }
    | RunnableBranch(
        (lambda x: "product_search" in x["intent"], rag_chain),
        general_chat_chain,
    )
)

# --- FASTAPI WEB SERVER ---

app = FastAPI(title="Supabase E-commerce Chatbot API")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/", summary="API Status Check")
def read_root():
    return {"status": "API is running"}

@app.get("/product/{product_id}", summary="Get Single Product Details")
async def get_product(product_id: str):
    try:
        response = supabase.table("cases").select("*").eq("id", product_id).single().execute()
        if not response.data:
            raise HTTPException(status_code=404, detail="Product not found")
        return response.data
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Code Generated by Sidekick is for learning and experimentation purposes only.
@app.post("/chat", response_model=ChatResponse, summary="Handle Chat Messages")
async def chat(request: ChatRequest):
    print(f"Received message: '{request.message}'")
    try:
        static_intent = detect_static_intent(request.message)
        if static_intent == "top_selling":
            print("Bot intent: DB search (top_selling)")
            print("searching ...")
            results_json = search_top_selling_in_supabase()
            return ChatResponse(reply=format_top_selling(results_json))
        faq_answer = match_faq(request.message)
        if faq_answer:
            print("Bot intent: General answer (FAQ)")
            return ChatResponse(reply=faq_answer)
        # Otherwise, use LLM pipeline to classify intent
        # We'll check if the intent is product_search (DB) or general_chat
        pipeline_intent = main_pipeline.invoke({"message": request.message})
        # If main_pipeline is a DB search, print accordingly
        # Since main_pipeline uses a RunnableBranch, we need to check what it returns
        # We'll use the intent classifier directly for logging
        intent_classifier = (
            ChatPromptTemplate.from_template(
                "Classify intent as 'product_search' or 'general_chat'. Message: {message}"
            ) | llm | StrOutputParser()
        )
        intent = intent_classifier.invoke({"message": request.message})
        if "product_search" in intent:
            print("Bot intent: DB search (product_search)")
            print("searching ...")
        else:
            print("Bot intent: General answer (chat)")
        return ChatResponse(reply=pipeline_intent)
    except Exception as e:
        print(f"Error during pipeline invocation: {e}")
        raise HTTPException(status_code=500, detail=str(e))


if __name__ == "__main__":
    uvicorn.run("check:app", host="0.0.0.0", port=8000, reload=True)
