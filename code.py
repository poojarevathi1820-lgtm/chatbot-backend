# Code Generated by Sidekick is for learning and experimentation purposes only.

import os
import json
import re
from typing import Optional

import uvicorn
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from supabase.client import Client, create_client

from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnableBranch, RunnableLambda
from langchain_core.output_parsers import StrOutputParser
from langchain_google_genai import ChatGoogleGenerativeAI

# --- STATIC DATA ---

NEW_ARRIVALS = [
    {
        "name": "Pixel Grip Case",
        "image": "https://jlmhfxqiendvjucpcnee.supabase.co/storage/v1/object/public/case/cases/Generated%20image%201%20(8).png"
    },
    {
        "name": "Pastel Blue Armor",
        "image": "https://jlmhfxqiendvjucpcnee.supabase.co/storage/v1/object/public/case/cases/Generated%20image%201%20(7).png"
    },
    {
        "name": "Frosted Matte Cover",
        "image": "https://jlmhfxqiendvjucpcnee.supabase.co/storage/v1/object/public/case/cases/Generated%20image%201%20(9).png"
    },
    {
        "name": "Clear Shockproof Shell",
        "image": "https://jlmhfxqiendvjucpcnee.supabase.co/storage/v1/object/public/case/cases/Generated%20image%201%20(6).png"
    }
]

FAQS = {
    "best material": "The best material depends on your needs. TPU and silicone offer flexibility and grip, polycarbonate is very durable, and leather is stylish.",
    "protect from drops": "Yes, our cases are designed to protect your phone from everyday bumps and drops. Rugged and shockproof models offer the highest protection.",
    "wireless charging": "Most of our slim and regular-fit cases are compatible with wireless charging. Very thick or metal cases may interfere.",
    "clean case": "Gently scrub with warm water and dish soap. For tough stains, use a baking soda paste. Remove your phone before cleaning.",
    "yellow case": "Yellowing is due to UV and skin oils. Cleaning with baking soda may help, but regular cleaning is best to prevent it.",
    "warranty": "We offer a one-year warranty covering manufacturing defects. Contact support with proof of purchase for claims."
}

FAQ_KEYWORDS = {
    "material": "best material",
    "drop": "protect from drops",
    "drops": "protect from drops",
    "wireless": "wireless charging",
    "charging": "wireless charging",
    "clean": "clean case",
    "yellow": "yellow case",
    "warranty": "warranty"
}

FAQ_PHRASES = [
    ("best material", ["best material", "what material", "which material"]),
    ("protect from drops", ["protect from drops", "drop protection", "protect my phone", "shockproof"]),
    ("wireless charging", ["wireless charging", "charge wirelessly", "wireless charger", "support wireless"]),
    ("clean case", ["clean case", "how to clean", "clean my case", "cleaning case"]),
    ("yellow case", ["yellow case", "case turned yellow", "clear case yellow", "yellowing"]),
    ("warranty", ["warranty", "guarantee", "return policy", "replace my case"])
]
# Code Generated by Sidekick is for learning and experimentation purposes only.

import re
from typing import Optional

def detect_static_intent(message: str) -> Optional[str]:
    msg = message.lower().strip()
    tokens = set(re.findall(r'\w+', msg))

    # Robust phrase matching for new arrivals
    new_arrivals_patterns = [
        r"\bnew arrivals\b",
        r"\blatest cases\b",
        r"\bwhat'?s new\b",
        r"\brecent cases\b",
        r"\bjust arrived\b",
        r"\bnewest cases\b",
        r"\bshow me new arrivals\b",
        r"\bsee new arrivals\b",
        r"\bany new arrivals\b",
        r"\bcan i see new arrivals\b",
        r"\bdo you have new arrivals\b",
        r"\bwhat are your new arrivals\b"
    ]
    for pattern in new_arrivals_patterns:
        if re.search(pattern, msg):
            return "new_arrivals"

    # Flexible token logic (optional, can be omitted if above is sufficient)
    if (
        ("new" in tokens and ("arrival" in tokens or "arrivals" in tokens or "case" in tokens or "cases" in tokens)) or
        ("latest" in tokens and ("case" in tokens or "cases" in tokens)) or
        ("recent" in tokens and ("case" in tokens or "cases" in tokens)) or
        ("show" in tokens and ("new" in tokens or "latest" in tokens or "recent" in tokens)) or
        ("what" in tokens and "new" in tokens) or
        ("see" in tokens and "new" in tokens) or
        ("any" in tokens and "new" in tokens)
    ):
        return "new_arrivals"

    # FAQ detection (make sure FAQ_PHRASES and FAQ_KEYWORDS are defined)
    for faq_key, phrases in FAQ_PHRASES:
        for phrase in phrases:
            if phrase in msg:
                return "faq"
    for keyword in FAQ_KEYWORDS:
        if keyword in tokens or keyword + "s" in tokens:
            return "faq"

    return None

def format_new_arrivals():
    html = "<h3>Here are our latest arrivals! ðŸŽ‰</h3><div style='display:flex;flex-wrap:wrap;gap:16px;'>"
    for item in NEW_ARRIVALS:
        html += (
            f"<div style='width:150px;text-align:center;'>"
            f"<img src='{item['image']}' alt='{item['name']}' style='width:100%;border-radius:8px;'/>"
            f"<div style='margin-top:8px;font-weight:bold;'>{item['name']}</div>"
            f"</div>"
        )
    html += "</div><p>Let me know if you'd like more details or want to order any of these!</p>"
    return html

def match_faq(user_message: str) -> Optional[str]:
    msg = user_message.lower()
    tokens = set(re.findall(r'\w+', msg))
    for faq_key, phrases in FAQ_PHRASES:
        for phrase in phrases:
            if phrase in msg:
                return f"<b>FAQ:</b> {FAQS[faq_key]}"
    for keyword, faq_key in FAQ_KEYWORDS.items():
        if keyword in tokens or keyword + "s" in tokens:
            return f"<b>FAQ:</b> {FAQS[faq_key]}"
    return None

# --- INITIALIZATION AND CONFIGURATION ---

load_dotenv()
supabase_url = os.getenv("SUPABASE_URL")
supabase_key = os.getenv("SUPABASE_KEY")
google_api_key = os.getenv("GOOGLE_API_KEY")

if not all([supabase_url, supabase_key, google_api_key]):
    raise ValueError("Supabase URL/Key and Google API Key must be set in the .env file.")

try:
    supabase: Client = create_client(supabase_url, supabase_key)
    print("Successfully connected to Supabase.")
except Exception as e:
    print(f"Error connecting to Supabase: {e}")
    exit()

# --- API DATA SCHEMAS ---

class ChatRequest(BaseModel):
    session_id: str
    message: str

class ChatResponse(BaseModel):
    reply: str

# --- HELPER FUNCTIONS ---

def format_search_results(results_json: str) -> str:
    try:
        results = json.loads(results_json)
        if "error" in results or not results:
            return "<p>Sorry, I couldn't find any cases matching your search. Please try another model!</p>"
        results_to_display = results[:3]
        html_responses = ["<p>Here are the top results I found:</p>"]
        for case in results_to_display:
            case_id = case.get('id', '')
            name = case.get('name', 'N/A')
            cost = case.get('cost', 'N/A')
            image_url = case.get('image_url', '')
            response_html = (
                f"<div style='margin-top: 15px;'>"
                f"<p style='margin:0; font-weight: bold;'>{name}</p>"
          
                 f"<p style='margin:0;'><b>Price:</b> &#8377; {cost}</p>"

                f'<a href="product.html?id={case_id}" target="_blank" title="View Details for {name}">'
                f'<img src="{image_url}" alt="{name}" style="max-width: 100%; height: auto; border-radius: 10px; margin-top: 5px; cursor: pointer;" />'
                f'</a>'
                f"</div>"
            )
            html_responses.append(response_html)
        if len(results) > 3:
            see_more_link = "<p style='text-align:center; margin-top: 20px;'><a href='cases.html' target='_blank'>See More Cases</a></p>"
            html_responses.append(see_more_link)
        return "".join(html_responses)
    except json.JSONDecodeError:
        return "<p>Error: I had trouble processing the search results.</p>"

def parse_brand_model(extracted: str) -> dict:
    brand = ''
    model = ''
    for part in extracted.split(','):
        part = part.strip()
        if part.lower().startswith('brand:'):
            brand = part.split(':', 1)[1].strip()
        elif part.lower().startswith('model:'):
            model = part.split(':', 1)[1].strip()
    return {'brand': brand, 'model': model}

def search_cases_in_supabase(brand: str, model: str) -> str:
    try:
        query = supabase.table("cases").select(
            "id, name, model, brand, color, material, image_url, cost"
        )
        if brand and model:
            query = query.ilike("brand", f"%{brand}%").ilike("model", f"%{model}%")
        elif brand:
            query = query.ilike("brand", f"%{brand}%")
        elif model:
            query = query.ilike("model", f"%{model}%")
        else:
            return json.dumps([])
        query = query.limit(10)
        response = query.execute()
        return json.dumps(response.data) if response.data else json.dumps([])
    except Exception as e:
        print(f"!!! DATABASE ERROR: {e} !!!")
        return json.dumps({"error": "Failed to query the database."})

# --- LANGCHAIN PIPELINE ---

llm = ChatGoogleGenerativeAI(model="gemini-1.5-flash-latest", temperature=0.0)

keyword_extraction_chain = (
    ChatPromptTemplate.from_template(
        "Extract the product brand and model from this message: {message}. "
        "Return as: brand: <brand>, model: <model>. If either is missing, leave blank."
    )
    | llm
    | StrOutputParser()
)

rag_chain = (
    {"message": lambda x: x["message"]}
    | {"extracted": keyword_extraction_chain}
    | RunnableLambda(lambda x: parse_brand_model(x["extracted"]))
    | RunnableLambda(lambda x: search_cases_in_supabase(brand=x["brand"], model=x["model"]))
    | RunnableLambda(format_search_results)
)

general_chat_chain = (
    ChatPromptTemplate.from_template("Respond warmly: {message}") | llm | StrOutputParser()
)

main_pipeline = (
    {"message": lambda x: x["message"]}
    | {
        "intent": ChatPromptTemplate.from_template(
            "Classify intent as 'product_search' or 'general_chat'. Message: {message}"
        ) | llm | StrOutputParser(),
        "message": lambda x: x["message"],
    }
    | RunnableBranch(
        (lambda x: "product_search" in x["intent"], rag_chain),
        general_chat_chain,
    )
)

# --- FASTAPI WEB SERVER ---

app = FastAPI(title="Supabase E-commerce Chatbot API")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/", summary="API Status Check")
def read_root():
    return {"status": "API is running"}

@app.get("/product/{product_id}", summary="Get Single Product Details")
async def get_product(product_id: str):
    try:
        response = supabase.table("cases").select("*").eq("id", product_id).single().execute()
        if not response.data:
            raise HTTPException(status_code=404, detail="Product not found")
        return response.data
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/chat", response_model=ChatResponse, summary="Handle Chat Messages")
async def chat(request: ChatRequest):
    print(f"Received message: '{request.message}'")
    try:
        static_intent = detect_static_intent(request.message)
        if static_intent == "new_arrivals":
            return ChatResponse(reply=format_new_arrivals())
        faq_answer = match_faq(request.message)
        if faq_answer:
            return ChatResponse(reply=faq_answer)
        # Otherwise, use LLM pipeline
        response = main_pipeline.invoke({"message": request.message})
        return ChatResponse(reply=response)
    except Exception as e:
        print(f"Error during pipeline invocation: {e}")
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    uvicorn.run("code:app", host="0.0.0.0", port=8000, reload=True)
