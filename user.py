# Code Generated by Sidekick is for learning and experimentation purposes only.
import os
import json
import re
from typing import Optional

import uvicorn
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from supabase.client import Client, create_client

from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnableBranch, RunnableLambda
from langchain_core.output_parsers import StrOutputParser
from langchain_google_genai import ChatGoogleGenerativeAI

# --- STATIC DATA ---
FAQS = {
    "best material": "The best material depends on your needs. TPU and silicone offer flexibility and grip, polycarbonate is very durable, and leather is stylish.",
    "protect from drops": "Yes, our cases are designed to protect your phone from everyday bumps and drops. Rugged and shockproof models offer the highest protection.",
    "wireless charging": "Most of our slim and regular-fit cases are compatible with wireless charging. Very thick or metal cases may interfere.",
    "clean case": "Gently scrub with warm water and dish soap. For tough stains, use a baking soda paste. Remove your phone before cleaning.",
    "yellow case": "Yellowing is due to UV and skin oils. Cleaning with baking soda may help, but regular cleaning is best to prevent it.",
    "warranty": "We offer a one-year warranty covering manufacturing defects. Contact support with proof of purchase for claims."
}
FAQ_KEYWORDS = {
    "material": "best material",
    "drop": "protect from drops",
    "drops": "protect from drops",
    "wireless": "wireless charging",
    "charging": "wireless charging",
    "clean": "clean case",
    "yellow": "yellow case",
    "warranty": "warranty"
}
FAQ_PHRASES = [
    ("best material", ["best material", "what material", "which material"]),
    ("protect from drops", ["protect from drops", "drop protection", "protect my phone", "shockproof"]),
    ("wireless charging", ["wireless charging", "charge wirelessly", "wireless charger", "support wireless"]),
    ("clean case", ["clean case", "how to clean", "clean my case", "cleaning case"]),
    ("yellow case", ["yellow case", "case turned yellow", "clear case yellow", "yellowing"]),
    ("warranty", ["warranty", "guarantee", "return policy", "replace my case"])
]

# --- INTENT DETECTION ---
def detect_static_intent(message: str) -> Optional[str]:
    msg = message.lower().strip()
    tokens = set(re.findall(r'\w+', msg))

    # Top selling detection
    top_selling_patterns = [
        r"\btop selling\b", r"\bbest sellers\b", r"\bmost popular\b",
        r"\bpopular cases\b", r"\bbest selling\b", r"\bshow me top selling\b",
        r"\bsee top selling\b", r"\bany top selling\b", r"\bcan i see top selling\b",
        r"\bdo you have top selling\b", r"\bwhat are your top selling\b"
    ]
    for pattern in top_selling_patterns:
        if re.search(pattern, msg):
            return "top_selling"
    if (
        ("top" in tokens and ("selling" in tokens or "seller" in tokens or "sellers" in tokens)) or
        ("best" in tokens and ("seller" in tokens or "sellers" in tokens or "selling" in tokens)) or
        ("popular" in tokens and ("case" in tokens or "cases" in tokens))
    ):
        return "top_selling"

    # New arrivals detection
    new_arrivals_patterns = [
        r"\bnew arrivals\b", r"\bjust arrived\b", r"\bnew cases\b",
        r"\blatest arrivals\b", r"\blatest cases\b", r"\bshow me new arrivals\b",
        r"\bsee new arrivals\b", r"\bany new arrivals\b", r"\bcan i see new arrivals\b",
        r"\bdo you have new arrivals\b", r"\bwhat are your new arrivals\b"
    ]
    for pattern in new_arrivals_patterns:
        if re.search(pattern, msg):
            return "new_arrivals"
    if (
        ("new" in tokens and ("arrival" in tokens or "arrivals" in tokens or "case" in tokens or "cases" in tokens)) or
        ("latest" in tokens and ("arrival" in tokens or "arrivals" in tokens or "case" in tokens or "cases" in tokens)) or
        ("just" in tokens and "arrived" in tokens)
    ):
        return "new_arrivals"

    # FAQ detection
    for faq_key, phrases in FAQ_PHRASES:
        for phrase in phrases:
            if phrase in msg:
                return "faq"
    for keyword in FAQ_KEYWORDS:
        if keyword in tokens or keyword + "s" in tokens:
            return "faq"
    return None

def match_faq(user_message: str) -> Optional[str]:
    msg = user_message.lower()
    tokens = set(re.findall(r'\w+', msg))
    for faq_key, phrases in FAQ_PHRASES:
        for phrase in phrases:
            if phrase in msg:
                return f"<b>FAQ:</b> {FAQS[faq_key]}"
    for keyword, faq_key in FAQ_KEYWORDS.items():
        if keyword in tokens or keyword + "s" in tokens:
            return f"<b>FAQ:</b> {FAQS[faq_key]}"
    return None

def format_top_selling(results_json: str) -> str:
    try:
        results = json.loads(results_json)
        if "error" in results or not results:
            return "<p>Sorry, I couldn't find any top selling cases. Please try again later!</p>"
        results_to_display = results[:3]
        html_responses = ["<h3>Here are our top selling cases! ðŸ”¥</h3><div style='display:flex;flex-wrap:wrap;gap:16px;'>"]
        from urllib.parse import quote
        for case in results_to_display:
            case_id = case.get('id', '')
            name = case.get('name', 'N/A')
            cost = case.get('cost', 'N/A')
            image_url = case.get('image_url', '')
            encoded_image_url = quote(image_url, safe='')
            response_html = (
                f"<div style='width:150px;text-align:center;'>"
                f'<a href="product.html?id={case_id}&image_url={encoded_image_url}" target="_blank" title="View Details for {name}">'
                f"<img src='{image_url}' alt='{name}' style='width:100%;border-radius:8px;cursor:pointer;'/>"
                f"</a>"
                f"<div style='margin-top:8px;font-weight:bold;'>{name}</div>"
                f"<div style='margin-top:4px;'>â‚¹{cost}</div>"
                f"</div>"
            )
            html_responses.append(response_html)
        html_responses.append("</div><p>Let me know if you'd like more details or want to order any of these!</p>")
        return "".join(html_responses)
    except json.JSONDecodeError:
        return "<p>Error: I had trouble processing the top selling results.</p>"

def format_new_arrivals(results_json: str) -> str:
    try:
        results = json.loads(results_json)
        if "error" in results or not results:
            return "<p>Sorry, I couldn't find any new arrivals. Please check back soon!</p>"
        results_to_display = results[:3]
        html_responses = [
            "<h3>Check out our latest arrivals! ðŸ†•</h3><div style='display:flex;flex-wrap:wrap;gap:16px;'>"
        ]
        for case in results_to_display:
            case_id = case.get('id', '')
            name = case.get('name', 'N/A')
            cost = case.get('cost', 'N/A')
            image_url = case.get('image_url', '')
            response_html = (
                f"<div style='width:150px;text-align:center;'>"
                f'<a href="product.html?id={case_id}" target="_blank" title="View Details for {name}">'
                f"<img src='{image_url}' alt='{name}' style='width:100%;border-radius:8px;cursor:pointer;'/>"
                f"</a>"
                f"<div style='margin-top:8px;font-weight:bold;'>{name}</div>"
                f"<div style='margin-top:4px;'>â‚¹{cost}</div>"
                f"</div>"
            )
            html_responses.append(response_html)
        html_responses.append("</div>")
        if len(results) > 3:
            see_more_link = "<p style='text-align:center; margin-top: 20px;'><a href='cases.html?filter=new' target='_blank'>See More cases</a></p>"
            html_responses.append(see_more_link)
        return "".join(html_responses)
    except json.JSONDecodeError:
        return "<p>Error: I had trouble processing the new arrivals data.</p>"

def format_search_results(results_json: str) -> str:
    try:
        results = json.loads(results_json)
        if "error" in results or not results:
            return "<p>Sorry, I couldn't find any cases matching your search. Please try another model!</p>"
        results_to_display = results[:3]
        html_responses = [
            "<h3>Here are the top results I found:</h3><div style='display:flex;flex-wrap:wrap;gap:16px;'>"
        ]
        for case in results_to_display:
            case_id = case.get('id', '')
            name = case.get('name', 'N/A')
            cost = case.get('cost', 'N/A')
            image_url = case.get('image_url', '')
            response_html = (
                f"<div style='width:150px;text-align:center;'>"
                f'<a href="product.html?id={case_id}" target="_blank" title="View Details for {name}">'
                f"<img src='{image_url}' alt='{name}' style='width:100%;border-radius:8px;cursor:pointer;'/>"
                f"</a>"
                f"<div style='margin-top:8px;font-weight:bold;'>{name}</div>"
                f"<div style='margin-top:4px;'>â‚¹{cost}</div>"
                f"</div>"
            )
            html_responses.append(response_html)
        html_responses.append("</div>")
        if len(results) > 3:
            see_more_link = "<p style='text-align:center; margin-top: 20px;'><a href='cases.html' target='_blank'>See More Cases</a></p>"
            html_responses.append(see_more_link)
        return "".join(html_responses)
    except json.JSONDecodeError:
        return "<p>Error: I had trouble processing the search results.</p>"

def parse_brand_model(extracted: str) -> dict:
    brand = ''
    model = ''
    for part in extracted.split(','):
        part = part.strip()
        if part.lower().startswith('brand:'):
            brand = part.split(':', 1)[1].strip()
        elif part.lower().startswith('model:'):
            model = part.split(':', 1)[1].strip()
    return {'brand': brand, 'model': model}

# --- DATABASE QUERY FUNCTIONS ---
def search_cases_in_supabase(brand: str = "", model: str = "") -> str:
    try:
        query = supabase.table("cases").select(
            "id, name, model, brand, color, material, image_url, cost"
        )
        brand = brand.strip().lower()
        model = model.strip().lower()
        if brand and model:
            query = query.ilike("brand", f"%{brand}%").ilike("model", f"%{model}%")
        elif brand:
            query = query.or_(
                f"brand.ilike.%{brand}%,model.ilike.%{brand}%"
            )
        elif model:
            query = query.or_(
                f"brand.ilike.%{model}%,model.ilike.%{model}%"
            )
        else:
            return json.dumps([])
        query = query.limit(10)
        response = query.execute()
        return json.dumps(response.data) if response.data else json.dumps([])
    except Exception as e:
        print(f"!!! DATABASE ERROR: {e} !!!")
        return json.dumps({"error": "Failed to query the database."})

def search_new_arrivals_in_supabase() -> str:
    try:
        query = supabase.table("new_arrivals").select(
            "name,model,cost,id,image_url,arrived_date"
        ).order("arrived_date", desc=True).limit(10)
        response = query.execute()
        return json.dumps(response.data) if response.data else json.dumps([])
    except Exception as e:
        print(f"!!! DATABASE ERROR: {e} !!!")
        return json.dumps({"error": "Failed to query the database."})

def search_top_selling_in_supabase() -> str:
    try:
        query = supabase.table("top_selling").select(
            "name,model,cost,image_url,id"
        ).limit(10)
        response = query.execute()
        return json.dumps(response.data) if response.data else json.dumps([])
    except Exception as e:
        print(f"!!! DATABASE ERROR: {e} !!!")
        return json.dumps({"error": "Failed to query the database."})

# --- INITIALIZATION AND CONFIGURATION ---
load_dotenv()
supabase_url = os.getenv("SUPABASE_URL")
supabase_key = os.getenv("SUPABASE_KEY")
google_api_key = os.getenv("GOOGLE_API_KEY")

if not all([supabase_url, supabase_key, google_api_key]):
    raise ValueError("Supabase URL/Key and Google API Key must be set in the .env file.")

try:
    supabase: Client = create_client(supabase_url, supabase_key)
    print("Successfully connected to Supabase.")
except Exception as e:
    print(f"Error connecting to Supabase: {e}")
    exit()

# --- API DATA SCHEMAS ---
class ChatRequest(BaseModel):
    session_id: str
    message: str

class ChatResponse(BaseModel):
    reply: str

# --- LANGCHAIN PIPELINE ---
llm = ChatGoogleGenerativeAI(model="gemini-1.5-flash-latest", temperature=0.0)

keyword_extraction_chain = (
    ChatPromptTemplate.from_template(
        "Extract the product brand and model from this message: {message}. "
        "Return as: brand: <brand>, model: <model>. If either is missing, leave blank."
    )
    | llm
    | StrOutputParser()
)

rag_chain = (
    {"message": lambda x: x["message"]}
    | {"extracted": keyword_extraction_chain}
    | RunnableLambda(lambda x: parse_brand_model(x["extracted"]))
    | RunnableLambda(lambda x: search_cases_in_supabase(brand=x["brand"], model=x["model"]))
    | RunnableLambda(format_search_results)
)

general_chat_chain = (
    ChatPromptTemplate.from_template("Respond warmly: {message}") | llm | StrOutputParser()
)

main_pipeline = (
    {"message": lambda x: x["message"]}
    | {
        "intent": ChatPromptTemplate.from_template(
            "Classify intent as 'product_search' or 'general_chat'. Message: {message}"
        ) | llm | StrOutputParser(),
        "message": lambda x: x["message"],
    }
    | RunnableBranch(
        (lambda x: "product_search" in x["intent"], rag_chain),
        general_chat_chain,
    )
)

# --- FASTAPI WEB SERVER ---
app = FastAPI(title="Supabase E-commerce Chatbot API")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/", summary="API Status Check")
def read_root():
    return {"status": "API is running"}

@app.get("/product/{product_id}", summary="Get Single Product Details")
async def get_product(product_id: str):
    try:
        response = supabase.table("cases").select("*").eq("id", product_id).single().execute()
        if not response.data:
            raise HTTPException(status_code=404, detail="Product not found")
        return response.data
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
# Code Generated by Sidekick is for learning and experimentation purposes only.
@app.post("/chat", response_model=ChatResponse, summary="Handle Chat Messages")
async def chat(request: ChatRequest):
    print(f"Received message: '{request.message}'")
    try:
        static_intent = detect_static_intent(request.message)

        # Top selling cases
        if static_intent == "top_selling":
            results_json = search_top_selling_in_supabase()
            return ChatResponse(reply=format_top_selling(results_json))

        # New arrivals
        if static_intent == "new_arrivals":
            results_json = search_new_arrivals_in_supabase()
            return ChatResponse(reply=format_new_arrivals(results_json))

        # FAQ
        if static_intent == "faq":
            faq_answer = match_faq(request.message)
            if faq_answer:
                return ChatResponse(reply=faq_answer)
            # If intent is FAQ but no answer found, continue to LLM

        # Dynamic brand/model search using LLM extraction
        extraction = keyword_extraction_chain.invoke({"message": request.message})
        entities = parse_brand_model(extraction)
        brand = entities.get("brand", "")
        model = entities.get("model", "")

        if brand or model:
            results_json = search_cases_in_supabase(brand=brand, model=model)
            return ChatResponse(reply=format_search_results(results_json))

        # Fallback: Use LLM pipeline for general chat or unknown queries
        pipeline_response = main_pipeline.invoke({"message": request.message})
        return ChatResponse(reply=pipeline_response)

    except Exception as e:
        print(f"Error during pipeline invocation: {e}")
        raise HTTPException(status_code=500, detail=str(e))
